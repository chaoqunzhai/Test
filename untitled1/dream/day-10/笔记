输入输出 请求 就是I/0请求
一个进程中 至少有一个线程


2、一个进程可以使用多核，进程下的多线程可以 使用多核，多核是为多线程设计。
3、进程：一个程序要运行时所需的所有资源的集合。
4、线程：一道单一的指令的控制流，（专注做一件事），寄生在进程中。
5 、进程是资源的集合（车间），不做i具体事情，通过线程做具体事情，一个进程至少需要一个线程，唯一的线程即为主线程，一个进程可以有多个线程。 CPU的核的数量的越多，代表真正可以并发的线程越多。
6、两个进程之间的数据不共享,like qq with word.，互相不能访问，只有通过操作系统才能互相访问进程间的数据。
7、单一进程的多个线程之间共享资源和数据，并行运行。并行与否看CPU的核数量。
8、多个线程在涉及修改同一个数据时一定要加锁。
9、GLOBAL INTERPRETER LOCK 全局解释器注释锁。


子线程是并行 运行的

多线程内存共享
进程直接不能共享，如果要共享 必须借助第三方。例如队列，管道
如果非要进程直接数据共享:  进程数据共享也就是 在各进程直接copy一份数据，然后返回  消耗特别大

GIL 无论有多少核 只能有一个进程
python 假多线程的原因
因为:为python解释器里有一个独立的线程，每过一段时间它起wake up做一次全局轮询看看哪些内存数据是可以被清空的
此时你自己的程序 里的线程和 py解释器自己的线程是并发运行的，假设你的线程删除了一个变量
py解释器的垃圾回收线程在清空这个变量的过程中的clearing时刻，可能一个其它线程正好又重新给这个还没来及得清空的内存空间赋值了
结果就有可能新赋值的数据被删除了，为了解决类似的问题，python解释器简单粗暴的加了锁，即当一个线程运行时
其它人都不能动，这样就解决了上述的问题，  这可以说是Python早期版本的遗留问题。

Evernts 就是维护   event.walt()  等待标志位
                   event.set()  设置标志位
                   event.clear() 清除标志位

Querue    FIFO

队列是安全的 能保证数据的唯一性 是自动上锁的

join是线程 进程中都有的方法  是等待执行完毕 后在关闭
join()#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。



生产者消费者的2个主要作用
1.程序的解耦合
2.提高了程序的运行效率


进程池
#都是给主进程返回  子进程 的连接 返回的  只需要维护一个连接即可