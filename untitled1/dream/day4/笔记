

#函数不应该依赖外部的环境          函数是独立的
#赋值的时候 是依次运行 !! 如果  name赋值了一次，就不能再赋值了。前面的参数也必须指定
#所有的默认参数，都必须放在位置参数的后面。
#赋值的时候可以指定参数
#指定参数也需要放在后面
#非固定参数 *args, 打印效果为元组
#非固定参数 **kwargs   打印效果为字典      如果指定赋值例如name="stud"   那打印出来就是字典
# *args  必须在**kwargs 前面
其中*args **kwargs 只是名称定义如此。如果赋值的时候 可以不用这个字符串如  say(age='23',name='cq',uuid='gong zuo 3 old yesar',moeny='100000')


def sayhi():
    print("hellow , im chaoqun")

sayhi()

#全局变量  和  局部变量      如果全局和局部名称一样，但是代表的意思是不同 ，在内存里面的地址不同，也不会冲突  。
#局部变量是重新开了一个内存空间

局部改变为全局 尽量不要用
********
返回值：
1.一旦你的函数经过调用并开始执行，那你函数外部的程序，就没办法在控制函数的执行过程了
    此时外部程序只能安静的等待函数的执行机结果，为啥要等待函数结果，因为外部程序要根据函数的执行结果来决定下一步怎么走。这个执行结果就是以return的形式返回给外部程序
2. return 代表着一个   函数的结束
3. return 可以返回任意数据类型
4. 对于用户角度，函数可以返回任意数量的值，但对于py本身来讲，函数只能返回一个值(以元组的方式显示)


递归：循环到999就报错 防止内存溢出
1:必须有一个明确结束条件
2.每次进入一层递归时,问题规模相比上次递归都应有所减少


lamda
map 把每个值取出来 ，让函数去执行

abs 求绝对值


编程范式：

面向过程
面向对象
函数式编程

bytes值可以用bytearray修改
exec内置函数，能执行程序

print(globals()) #把当前程序所在内存里的所有数据都以字典的形式打印出来

set 把列表变成集合